import { __commonJS, __require, __toDynamicImportESM, __toESM } from "./dep-lCKrEJQm.js";
import { LogLevels, createLogger, printServerUrls, require_picocolors } from "./dep-D5MCzjWT.js";
import { CLIENT_DIR, CLIENT_ENTRY, CLIENT_PUBLIC_PATH, CSS_LANGS_RE, DEFAULT_ASSETS_INLINE_LIMIT, DEFAULT_ASSETS_RE, DEFAULT_CLIENT_CONDITIONS, DEFAULT_CLIENT_MAIN_FIELDS, DEFAULT_CONFIG_FILES, DEFAULT_DEV_PORT, DEFAULT_EXTERNAL_CONDITIONS, DEFAULT_PREVIEW_PORT, DEFAULT_SERVER_CONDITIONS, DEFAULT_SERVER_MAIN_FIELDS, DEP_VERSION_RE, DEV_PROD_CONDITION, ENV_ENTRY, ENV_PUBLIC_PATH, ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR, ERR_OPTIMIZE_DEPS_PROCESSING_ERROR, ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET, FS_PREFIX, JS_TYPES_RE, KNOWN_ASSET_TYPES, METADATA_FILENAME, OPTIMIZABLE_ENTRY_RE, ROLLUP_HOOKS, SPECIAL_QUERY_RE, VERSION, VITE_PACKAGE_DIR, defaultAllowedOrigins, loopbackHosts, wildcardHosts } from "./dep-CcFMbzqu.js";
import { builtinModules, createRequire } from "node:module";
import { parseAst, parseAstAsync } from "rollup/parseAst";
import * as fs$1 from "node:fs";
import fs, { existsSync, promises, readFileSync } from "node:fs";
import path, { basename, dirname, extname, isAbsolute, join, normalize, posix, relative, resolve } from "node:path";
import fsp, { constants } from "node:fs/promises";
import { URL as URL$1, fileURLToPath, pathToFileURL } from "node:url";
import { format, inspect, promisify, stripVTControlCharacters } from "node:util";
import { performance as performance$1 } from "node:perf_hooks";
import crypto from "node:crypto";
import picomatch from "picomatch";
import esbuild, { build, formatMessages, transform } from "esbuild";
import os from "node:os";
import net from "node:net";
import childProcess, { exec, execFile, execSync } from "node:child_process";
import { promises as promises$1 } from "node:dns";
import path$1, { basename as basename$1, dirname as dirname$1, extname as extname$1, isAbsolute as isAbsolute$1, join as join$1, posix as posix$1, relative as relative$1, resolve as resolve$1, sep, win32 } from "path";
import { existsSync as existsSync$1, readFileSync as readFileSync$1, readdirSync, statSync } from "fs";
import { fdir } from "fdir";
import { gzip } from "node:zlib";
import readline from "node:readline";
import { createRequire as createRequire$1 } from "module";
import { MessageChannel, Worker } from "node:worker_threads";
import { Buffer as Buffer$1 } from "node:buffer";
import { escapePath, glob, globSync, isDynamicPattern } from "tinyglobby";
import assert from "node:assert";
import process$1 from "node:process";
import v8 from "node:v8";
import { EventEmitter } from "node:events";
import { STATUS_CODES, createServer, get } from "node:http";
import { createServer as createServer$1, get as get$1 } from "node:https";
import { ESModulesEvaluator, ModuleRunner, createNodeImportMeta } from "vite/module-runner";
import zlib from "zlib";
import * as qs from "node:querystring";

//#region src/shared/constants.ts
/**
* Prefix for resolved Ids that are not valid browser import specifiers
*/
const VALID_ID_PREFIX = `/@id/`;
/**
* Plugins that use 'virtual modules' (e.g. for helper functions), prefix the
* module ID with `\0`, a convention from the rollup ecosystem.
* This prevents other plugins from trying to process the id (like node resolution),
* and core features like sourcemaps can use this info to differentiate between
* virtual modules and regular files.
* `\0` is not a permitted char in import URLs so we have to replace them during
* import analysis. The id will be decoded back before entering the plugins pipeline.
* These encoded virtual ids are also prefixed by the VALID_ID_PREFIX, so virtual
* modules in the browser end up encoded as `/@id/__x00__{id}`
*/
const NULL_BYTE_PLACEHOLDER = `__x00__`;
let SOURCEMAPPING_URL = "sourceMa";
SOURCEMAPPING_URL += "ppingURL";
const MODULE_RUNNER_SOURCEMAPPING_SOURCE = "//# sourceMappingSource=vite-generated";
const ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP";

//#endregion
//#region src/shared/utils.ts
const isWindows = typeof process !== "undefined" && process.platform === "win32";
/**
* Prepend `/@id/` and replace null byte so the id is URL-safe.
* This is prepended to resolved ids that are not valid browser
* import specifiers by the importAnalysis plugin.
*/
function wrapId(id) {
	return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
/**
* Undo {@link wrapId}'s `/@id/` and null byte replacements.
*/
function unwrapId(id) {
	return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, "\0") : id;
}
const windowsSlashRE = /\\/g;
function slash(p) {
	return p.replace(windowsSlashRE, "/");
}
const postfixRE = /[?#].*$/;
function cleanUrl(url$3) {
	return url$3.replace(postfixRE, "");
}
function splitFileAndPostfix(path$13) {
	const file = cleanUrl(path$13);
	return {
		file,
		postfix: path$13.slice(file.length)
	};
}
function withTrailingSlash(path$13) {
	if (path$13[path$13.length - 1] !== "/") return `${path$13}/`;
	return path$13;
}
const AsyncFunction$1 = async function() {}.constructor;
function promiseWithResolvers() {
	let resolve$4;
	let reject;
	const promise = new Promise((_resolve, _reject) => {
		resolve$4 = _resolve;
		reject = _reject;
	});
	return {
		promise,
		resolve: resolve$4,
		reject
	};
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
const comma = ",".charCodeAt(0);
const semicolon = ";".charCodeAt(0);
const chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for (let i$1 = 0; i$1 < 64; i$1++) {
	const c = chars$1.charCodeAt(i$1);
	intToChar[i$1] = c;
	charToInt[c] = i$1;
}
function decodeInteger(reader, relative$3) {
	let value$1 = 0;
	let shift = 0;
	let integer = 0;
	do {
		const c = reader.next();
		integer = charToInt[c];
		value$1 |= (integer & 31) << shift;
		shift += 5;
	} while (integer & 32);
	const shouldNegate = value$1 & 1;
	value$1 >>>= 1;
	if (shouldNegate) value$1 = -2147483648 | -value$1;
	return relative$3 + value$1;
}
function encodeInteger(builder, num, relative$3) {
	let delta = num - relative$3;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
function hasMoreVlq(reader, max) {
	if (reader.pos >= max) return false;
	return reader.peek() !== comma;
}
const bufLength = 1024 * 16;
const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
	return out.toString();
} } : { decode(buf) {
	let out = "";
	for (let i$1 = 0; i$1 < buf.length; i$1++) out += String.fromCharCode(buf[i$1]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v) {
		const { buffer } = this;
		buffer[this.pos++] = v;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
var StringReader = class {
	constructor(buffer) {
		this.pos = 0;
		this.buffer = buffer;
	}
	next() {
		return this.buffer.charCodeAt(this.pos++);
	}
	peek() {
		return this.buffer.charCodeAt(this.pos);
	}
	indexOf(char) {
		const { buffer, pos } = this;
		const idx = buffer.indexOf(char, pos);
		return idx === -1 ? buffer.length : idx;
	}
};
function decode(mappings) {
	const { length } = mappings;
	const reader = new StringReader(mappings);
	const decoded = [];
	let genColumn = 0;
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	do {
		const semi = reader.indexOf(";");
		const line = [];
		let sorted = true;
		let lastCol = 0;
		genColumn = 0;
		while (reader.pos < semi) {
			let seg;
			genColumn = decodeInteger(reader, genColumn);
			if (genColumn < lastCol) sorted = false;
			lastCol = genColumn;
			if (hasMoreVlq(reader, semi)) {
				sourcesIndex = decodeInteger(reader, sourcesIndex);
				sourceLine = decodeInteger(reader, sourceLine);
				sourceColumn = decodeInteger(reader, sourceColumn);
				if (hasMoreVlq(reader, semi)) {
					namesIndex = decodeInteger(reader, namesIndex);
					seg = [
						genColumn,
						sourcesIndex,
						sourceLine,
						sourceColumn,
						namesIndex
					];
				} else seg = [
					genColumn,
					sourcesIndex,
					sourceLine,
					sourceColumn
				];
			} else seg = [genColumn];
			line.push(seg);
			reader.pos++;
		}
		if (!sorted) sort(line);
		decoded.push(line);
		reader.pos = semi + 1;
	} while (reader.pos <= length);
	return decoded;
}
function sort(line) {
	line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
	return a[0] - b[0];
}
function encode$1(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i$1 = 0; i$1 < decoded.length; i$1++) {
		const line = decoded[i$1];
		if (i$1 > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j = 0; j < line.length; j++) {
			const segment = line[j];
			if (j > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
const schemeRegex = /^[\w+.-]+:\/\//;
/**
* Matches the parts of a URL:
* 1. Scheme, including ":", guaranteed.
* 2. User/password, including "@", optional.
* 3. Host, guaranteed.
* 4. Port, including ":", optional.
* 5. Path, including "/", optional.
* 6. Query, including "?", optional.
* 7. Hash, including "#", optional.
*/
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
*
* 1. Host, optional.
* 2. Path, which may include "/", guaranteed.
* 3. Query, including "?", optional.
* 4. Hash, including "#", optional.
*/
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
	return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
	return input.startsWith("//");
}
function isAbsolutePath(input) {
	return input.startsWith("/");
}
function isFileUrl(input) {
	return input.startsWith("file:");
}
function isRelative(input) {
	return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
	const match = urlRegex.exec(input);
	return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
	const match = fileRegex.exec(input);
	const path$13 = match[2];
	return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path$13) ? path$13 : "/" + path$13, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path$13, query, hash$1) {
	return {
		scheme,
		user,
		host,
		port,
		path: path$13,
		query,
		hash: hash$1,
		type: 7
	};
}
function parseUrl$3(input) {
	if (isSchemeRelativeUrl(input)) {
		const url$4 = parseAbsoluteUrl("http:" + input);
		url$4.scheme = "";
		url$4.type = 6;
		return url$4;
	}
	if (isAbsolutePath(input)) {
		const url$4 = parseAbsoluteUrl("http://foo.com" + input);
		url$4.scheme = "";
		url$4.host = "";
		url$4.type = 5;
		return url$4;
	}
	if (isFileUrl(input)) return parseFileUrl(input);
	if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
	const url$3 = parseAbsoluteUrl("http://foo.com/" + input);
	url$3.scheme = "";
	url$3.host = "";
	url$3.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
	return url$3;
}
function stripPathFilename(path$13) {
	if (path$13.endsWith("/..")) return path$13;
	const index = path$13.lastIndexOf("/");
	return path$13.slice(0, index + 1);
}
function mergePaths(url$3, base) {
	normalizePath$4(base, base.type);
	if (url$3.path === "/") url$3.path = base.path;
	else url$3.path = stripPathFilename(base.path) + url$3.path;
}
/**
* The path can have empty directories "//", unneeded parents "foo/..", or current directory
* "foo/.". We need to normalize to a standard representation.
*/
function normalizePath$4(url$3, type) {
	const rel = type <= 4;
	const pieces = url$3.path.split("/");
	let pointer = 1;
	let positive = 0;
	let addTrailingSlash = false;
	for (let i$1 = 1; i$1 < pieces.length; i$1++) {
		const piece = pieces[i$1];
		if (!piece) {
			addTrailingSlash = true;
			continue;
		}
		addTrailingSlash = false;
		if (piece === ".") continue;
		if (piece === "..") {
			if (positive) {
				addTrailingSlash = true;
				positive--;
				pointer--;
			} else if (rel) pieces[pointer++] = piece;
			continue;
		}
		pieces[pointer++] = piece;
		positive++;
	}
	let path$13 = "";
	for (let i$1 = 1; i$1 < pointer; i$1++) path$13 += "/" + pieces[i$1];
	if (!path$13 || addTrailingSlash && !path$13.endsWith("/..")) path$13 += "/";
	url$3.path = path$13;
}
/**
* Attempts to resolve `input` URL/path relative to `base`.
*/
function resolve$3(input, base) {
	if (!input && !base) return "";
	const url$3 = parseUrl$3(input);
	let inputType = url$3.type;
	if (base && inputType !== 7) {
		const baseUrl = parseUrl$3(base);
		const baseType = baseUrl.type;
		switch (inputType) {
			case 1: url$3.hash = baseUrl.hash;
			case 2: url$3.query = baseUrl.query;
			case 3:
			case 4: mergePaths(url$3, baseUrl);
			case 5:
				url$3.user = baseUrl.user;
				url$3.host = baseUrl.host;
				url$3.port = baseUrl.port;
			case 6: url$3.scheme = baseUrl.scheme;
		}
		if (baseType > inputType) inputType = baseType;
	}
	normalizePath$4(url$3, inputType);
	const queryHash = url$3.query + url$3.hash;
	switch (inputType) {
		case 2:
		case 3: return queryHash;
		case 4: {
			const path$13 = url$3.path.slice(1);
			if (!path$13) return queryHash || ".";
			if (isRelative(base || input) && !isRelative(path$13)) return "./" + path$13 + queryHash;
			return path$13 + queryHash;
		}
		case 5: return url$3.path + queryHash;
		default: return url$3.scheme + "//" + url$3.user + url$3.host + url$3.port + url$3.path + queryHash;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function stripFilename(path$13) {
	if (!path$13) return "";
	const index = path$13.lastIndexOf("/");
	return path$13.slice(0, index + 1);
}
function resolver(mapUrl, sourceRoot) {
	const from = stripFilename(mapUrl);
	const prefix = sourceRoot ? sourceRoot + "/" : "";
	return (source) => resolve$3(prefix + (source || ""), from);
}
var COLUMN$1 = 0;
var SOURCES_INDEX$1 = 1;
var SOURCE_LINE$1 = 2;
var SOURCE_COLUMN$1 = 3;
var NAMES_INDEX$1 = 4;
function maybeSort(mappings, owned) {
	const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
	if (unsortedIndex === mappings.length) return mappings;
	if (!owned) mappings = mappings.slice();
	for (let i$1 = unsortedIndex; i$1 < mappings.length; i$1 = nextUnsortedSegmentLine(mappings, i$1 + 1)) mappings[i$1] = sortSegments(mappings[i$1], owned);
	return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
	for (let i$1 = start; i$1 < mappings.length; i$1++) if (!isSorted(mappings[i$1])) return i$1;
	return mappings.length;
}
function isSorted(line) {
	for (let j = 1; j < line.length; j++) if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) return false;
	return true;
}
function sortSegments(line, owned) {
	if (!owned) line = line.slice();
	return line.sort(sortComparator);
}
function sortComparator(a, b) {
	return a[COLUMN$1] - b[COLUMN$1];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
	while (low <= high) {
		const mid = low + (high - low >> 1);
		const cmp = haystack[mid][COLUMN$1] - needle;
		if (cmp === 0) {
			found = true;
			return mid;
		}
		if (cmp < 0) low = mid + 1;
		else high = mid - 1;
	}
	found = false;
	return low - 1;
}
function upperBound(haystack, needle, index) {
	for (let i$1 = index + 1; i$1 < haystack.length; index = i$1++) if (haystack[i$1][COLUMN$1] !== needle) break;
	return index;
}
function lowerBound(haystack, needle, index) {
	for (let i$1 = index - 1; i$1 >= 0; index = i$1--) if (haystack[i$1][COLUMN$1] !== needle) break;
	return index;
}
function memoizedState() {
	return {
		lastKey: -1,
		lastNeedle: -1,
		lastIndex: -1
	};
}
function memoizedBinarySearch(haystack, needle, state, key) {
	const { lastKey, lastNeedle, lastIndex } = state;
	let low = 0;
	let high = haystack.length - 1;
	if (key === lastKey) {
		if (needle === lastNeedle) {
			found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
			return lastIndex;
		}
		if (needle >= lastNeedle) low = lastIndex === -1 ? 0 : lastIndex;
		else high = lastIndex;
	}
	state.lastKey = key;
	state.lastNeedle = needle;
	return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function parse$16(map$1) {
	return typeof map$1 === "string" ? JSON.parse(map$1) : map$1;
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
	constructor(map$1, mapUrl) {
		const isString$1 = typeof map$1 === "string";
		if (!isString$1 && map$1._decodedMemo) return map$1;
		const parsed = parse$16(map$1);
		const { version: version$2, file, names, sourceRoot, sources, sourcesContent } = parsed;
		this.version = version$2;
		this.file = file;
		this.names = names || [];
		this.sourceRoot = sourceRoot;
		this.sources = sources;
		this.sourcesContent = sourcesContent;
		this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
		const resolve$4 = resolver(mapUrl, sourceRoot);
		this.resolvedSources = sources.map(resolve$4);
		const { mappings } = parsed;
		if (typeof mappings === "string") {
			this._encoded = mappings;
			this._decoded = void 0;
		} else if (Array.isArray(mappings)) {
			this._encoded = void 0;
			this._decoded = maybeSort(mappings, isString$1);
		} else if (parsed.sections) throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
		else throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
		this._decodedMemo = memoizedState();
		this._bySources = void 0;
		this._bySourceMemos = void 0;
	}
};
function cast$1(map$1) {
	return map$1;
}
function encodedMappings(map$1) {
	var _a, _b;
	return (_b = (_a = cast$1(map$1))._encoded) != null ? _b : _a._encoded = encode$1(cast$1(map$1)._decoded);
}
function decodedMappings(map$1) {
	var _a;
	return (_a = cast$1(map$1))._decoded || (_a._decoded = decode(cast$1(map$1)._encoded));
}
function traceSegment(map$1, line, column) {
	const decoded = decodedMappings(map$1);
	if (line >= decoded.length) return null;
	const segments = decoded[line];
	const index = traceSegmentInternal(segments, cast$1(map$1)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
	return index === -1 ? null : segments[index];
}
function originalPositionFor(map$1, needle) {
	let { line, column, bias } = needle;
	line--;
	if (line < 0) throw new Error(LINE_GTR_ZERO);
	if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
	const decoded = decodedMappings(map$1);
	if (line >= decoded.length) return OMapping(null, null, null, null);
	const segments = decoded[line];
	const index = traceSegmentInternal(segments, cast$1(map$1)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
	if (index === -1) return OMapping(null, null, null, null);
	const segment = segments[index];
	if (segment.length === 1) return OMapping(null, null, null, null);
	const { names, resolvedSources } = map$1;
	return OMapping(resolvedSources[segment[SOURCES_INDEX$1]], segment[SOURCE_LINE$1] + 1, segment[SOURCE_COLUMN$1], segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null);
}
function decodedMap(map$1) {
	return clone(map$1, decodedMappings(map$1));
}
function encodedMap(map$1) {
	return clone(map$1, encodedMappings(map$1));
}
function clone(map$1, mappings) {
	return {
		version: map$1.version,
		file: map$1.file,
		names: map$1.names,
		sourceRoot: map$1.sourceRoot,
		sources: map$1.sources,
		sourcesContent: map$1.sourcesContent,
		mappings,
		ignoreList: map$1.ignoreList || map$1.x_google_ignoreList
	};
}
function OMapping(source, line, column, name) {
	return {
		source,
		line,
		column,
		name
	};
}
function traceSegmentInternal(segments, memo, line, column, bias) {
	let index = memoizedBinarySearch(segments, column, memo, line);
	if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
	else if (bias === LEAST_UPPER_BOUND) index++;
	if (index === -1 || index === segments.length) return -1;
	return index;
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.12/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var SetArray = class {
	constructor() {
		this._indexes = { __proto__: null };
		this.array = [];
	}
};
function cast(set) {
	return set;
}
function get$2(setarr, key) {
	return cast(setarr)._indexes[key];
}
function put(setarr, key) {
	const index = get$2(setarr, key);
	if (index !== void 0) return index;
	const { array, _indexes: indexes } = cast(setarr);
	const length = array.push(key);
	return indexes[key] = length - 1;
}
function remove(setarr, key) {
	const index = get$2(setarr, key);
	if (index === void 0) return;
	const { array, _indexes: indexes } = cast(setarr);
	for (let i$1 = index + 1; i$1 < array.length; i$1++) {
		const k = array[i$1];
		array[i$1 - 1] = k;
		indexes[k]--;
	}
	indexes[key] = void 0;
	array.pop();
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var NO_NAME = -1;
var GenMapping = class {
	constructor({ file, sourceRoot } = {}) {
		this._names = new SetArray();
		this._sources = new SetArray();
		this._sourcesContent = [];
		this._mappings = [];
		this.file = file;
		this.sourceRoot = sourceRoot;
		this._ignoreList = new SetArray();
	}
};
function cast2(map$1) {
	return map$1;
}
var maybeAddSegment = (map$1, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
	return addSegmentInternal(true, map$1, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
};
function setSourceContent(map$1, source, content) {
	const { _sources: sources, _sourcesContent: sourcesContent } = cast2(map$1);
	const index = put(sources, source);
	sourcesContent[index] = content;
}
function setIgnore(map$1, source, ignore = true) {
	const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast2(map$1);
	const index = put(sources, source);
	if (index === sourcesContent.length) sourcesContent[index] = null;
	if (ignore) put(ignoreList, index);
	else remove(ignoreList, index);
}
function toDecodedMap(map$1) {
	const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast2(map$1);
	removeEmptyFinalLines(mappings);
	return {
		version: 3,
		file: map$1.file || void 0,
		names: names.array,
		sourceRoot: map$1.sourceRoot || void 0,
		sources: sources.array,
		sourcesContent,
		mappings,
		ignoreList: ignoreList.array
	};
}
function toEncodedMap(map$1) {
	const decoded = toDecodedMap(map$1);
	return Object.assign({}, decoded, { mappings: encode$1(decoded.mappings) });
}
function addSegmentInternal(skipable, map$1, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
	const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast2(map$1);
	const line = getIndex(mappings, genLine);
	const index = getColumnIndex(line, genColumn);
	if (!source) {
		if (skipable && skipSourceless(line, index)) return;
		return insert(line, index, [genColumn]);
	}
	assert$2(sourceLine);
	assert$2(sourceColumn);
	const sourcesIndex = put(sources, source);
	const namesIndex = name ? put(names, name) : NO_NAME;
	if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
	if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) return;
	return insert(line, index, name ? [
		genColumn,
		sourcesIndex,
		sourceLine,
		sourceColumn,
		namesIndex
	] : [
		genColumn,
		sourcesIndex,
		sourceLine,
		sourceColumn
	]);
}
function assert$2(_val) {}
function getIndex(arr, index) {
	for (let i$1 = arr.length; i$1 <= index; i$1++) arr[i$1] = [];
	return arr[index];
}
function getColumnIndex(line, genColumn) {
	let index = line.length;
	for (let i$1 = index - 1; i$1 >= 0; index = i$1--) {
		const current = line[i$1];
		if (genColumn >= current[COLUMN]) break;
	}
	return index;
}
function insert(array, index, value$1) {
	for (let i$1 = array.length; i$1 > index; i$1--) array[i$1] = array[i$1 - 1];
	array[index] = value$1;
}
function removeEmptyFinalLines(mappings) {
	const { length } = mappings;
	let len = length;
	for (let i$1 = len - 1; i$1 >= 0; len = i$1, i$1--) if (mappings[i$1].length > 0) break;
	if (len < length) mappings.length = len;
}
function skipSourceless(line, index) {
	if (index === 0) return true;
	const prev = line[index - 1];
	return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
	if (index === 0) return false;
	const prev = line[index - 1];
	if (prev.length === 1) return false;
	return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+remapping@2.3.5/node_modules/@jridgewell/remapping/dist/remapping.mjs
var SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null, false);
var EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content, ignore) {
	return {
		source,
		line,
		column,
		name,
		content,
		ignore
	};
}
function Source(map$1, sources, source, content, ignore) {
	return {
		map: map$1,
		sources,
		source,
		content,
		ignore
	};
}
function MapSource(map$1, sources) {
	return Source(map$1, sources, "", null, false);
}
function OriginalSource(source, content, ignore) {
	return Source(null, EMPTY_SOURCES, source, content, ignore);
}
function traceMappings(tree) {
	const gen = new GenMapping({ file: tree.map.file });
	const { sources: rootSources, map: map$1 } = tree;
	const rootNames = map$1.names;
	const rootMappings = decodedMappings(map$1);
	for (let i$1 = 0; i$1 < rootMappings.length; i$1++) {
		const segments = rootMappings[i$1];
		for (let j = 0; j < segments.length; j++) {
			const segment = segments[j];
			const genCol = segment[0];
			let traced = SOURCELESS_MAPPING;
			if (segment.length !== 1) {
				const source2 = rootSources[segment[1]];
				traced = originalPositionFor$1(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
				if (traced == null) continue;
			}
			const { column, line, name, content, source, ignore } = traced;
			maybeAddSegment(gen, i$1, genCol, source, line, column, name);
			if (source && content != null) setSourceContent(gen, source, content);
			if (ignore) setIgnore(gen, source, true);
		}
	}
	return gen;
}
function originalPositionFor$1(source, line, column, name) {
	if (!source.map) return SegmentObject(source.source, line, column, name, source.content, source.ignore);
	const segment = traceSegment(source.map, line, column);
	if (segment == null) return null;
	if (segment.length === 1) return SOURCELESS_MAPPING;
	return originalPositionFor$1(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
}
function asArray(value$1) {
	if (Array.isArray(value$1)) return value$1;
	return [value$1];
}
function buildSourceMapTree(input, loader$1) {
	const maps = asArray(input).map((m$2) => new TraceMap(m$2, ""));
	const map$1 = maps.pop();
	for (let i$1 = 0; i$1 < maps.length; i$1++) if (maps[i$1].sources.length > 1) throw new Error(`Transformation map ${i$1} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
	let tree = build$2(map$1, loader$1, "", 0);
	for (let i$1 = maps.length - 1; i$1 >= 0; i$1--) tree = MapSource(maps[i$1], [tree]);
	return tree;
}
function build$2(map$1, loader$1, importer, importerDepth) {
	const { resolvedSources, sourcesContent, ignoreList } = map$1;
	const depth = importerDepth + 1;
	const children = resolvedSources.map((sourceFile, i$1) => {
		const ctx = {
			importer,
			depth,
			source: sourceFile || "",
			content: void 0,
			ignore: void 0
		};
		const sourceMap = loader$1(ctx.source, ctx);
		const { source, content, ignore } = ctx;
		if (sourceMap) return build$2(new TraceMap(sourceMap, source), loader$1, source, depth);
		const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i$1] : null;
		const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i$1) : false;
		return OriginalSource(source, sourceContent, ignored);
	});
	return MapSource(map$1, children);
}
var SourceMap$1 = class {
	constructor(map$1, options$1) {
		const out = options$1.decodedMappings ? toDecodedMap(map$1) : toEncodedMap(map$1);
		this.version = out.version;
		this.file = out.file;
		this.mappings = out.mappings;
		this.names = out.names;
		this.ignoreList = out.ignoreList;
		this.sourceRoot = out.sourceRoot;
		this.sources = out.sources;
		if (!options$1.excludeContent) this.sourcesContent = out.sourcesContent;
	}
	toString() {
		return JSON.stringify(this);
	}
};
function remapping(input, loader$1, options$1) {
	const opts = typeof options$1 === "object" ? options$1 : {
		excludeContent: !!options$1,
		decodedMappings: false
	};
	const tree = buildSourceMapTree(input, loader$1);
	return new SourceMap$1(traceMappings(tree), opts);
}

//#endregion
//#region ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s$1 = 1e3;
	var m$1 = s$1 * 60;
	var h$1 = m$1 * 60;
	var d$1 = h$1 * 24;
	var w = d$1 * 7;
	var y$1 = d$1 * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options$1) {
		options$1 = options$1 || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$15(val);
		else if (type === "number" && isFinite(val)) return options$1.long ? fmtLong$1(val) : fmtShort$1(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$15(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n$2 = parseFloat(match[1]);
		var type = (match[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n$2 * y$1;
			case "weeks":
			case "week":
			case "w": return n$2 * w;
			case "days":
			case "day":
			case "d": return n$2 * d$1;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n$2 * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n$2 * m$1;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n$2 * s$1;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n$2;
			default: return void 0;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort$1(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d$1) return Math.round(ms / d$1) + "d";
		if (msAbs >= h$1) return Math.round(ms / h$1) + "h";
		if (msAbs >= m$1) return Math.round(ms / m$1) + "m";
		if (msAbs >= s$1) return Math.round(ms / s$1) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong$1(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d$1) return plural$1(ms, msAbs, d$1, "day");
		if (msAbs >= h$1) return plural$1(ms, msAbs, h$1, "hour");
		if (msAbs >= m$1) return plural$1(ms, msAbs, m$1, "minute");
		if (msAbs >= s$1) return plural$1(ms, msAbs, s$1, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural$1(ms, msAbs, n$2, name) {
		var isPlural = msAbs >= n$2 * 1.5;
		return Math.round(ms / n$2) + " " + name + (isPlural ? "s" : "");
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js
var require_common$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env$1) {
		createDebug$1.debug = createDebug$1;
		createDebug$1.default = createDebug$1;
		createDebug$1.coerce = coerce$1;
		createDebug$1.disable = disable$1;
		createDebug$1.enable = enable$1;
		createDebug$1.enabled = enabled$1;
		createDebug$1.humanize = require_ms$1();
		createDebug$1.destroy = destroy$1;
		Object.keys(env$1).forEach((key) => {
			createDebug$1[key] = env$1[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug$1.names = [];
		createDebug$1.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug$1.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor$1(namespace) {
			let hash$1 = 0;
			for (let i$1 = 0; i$1 < namespace.length; i$1++) {
				hash$1 = (hash$1 << 5) - hash$1 + namespace.charCodeAt(i$1);
				hash$1 |= 0;
			}
			return createDebug$1.colors[Math.abs(hash$1) % createDebug$1.colors.length];
		}
		createDebug$1.selectColor = selectColor$1;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug$1(namespace) {
			let prevTime$1;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$19(...args) {
				if (!debug$19.enabled) return;
				const self$1 = debug$19;
				const curr = Number(/* @__PURE__ */ new Date());
				const ms = curr - (prevTime$1 || curr);
				self$1.diff = ms;
				self$1.prev = prevTime$1;
				self$1.curr = curr;
				prevTime$1 = curr;
				args[0] = createDebug$1.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format$3) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug$1.formatters[format$3];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug$1.formatArgs.call(self$1, args);
				const logFn = self$1.log || createDebug$1.log;
				logFn.apply(self$1, args);
			}
			debug$19.namespace = namespace;
			debug$19.useColors = createDebug$1.useColors();
			debug$19.color = createDebug$1.selectColor(namespace);
			debug$19.extend = extend;
			debug$19.destroy = createDebug$1.destroy;
			Object.defineProperty(debug$19, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug$1.namespaces) {
						namespacesCache = createDebug$1.namespaces;
						enabledCache = createDebug$1.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug$1.init === "function") createDebug$1.init(debug$19);
			return debug$19;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug$1(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable$1(namespaces) {
			createDebug$1.save(namespaces);
			createDebug$1.namespaces = namespaces;
			createDebug$1.names = [];
			createDebug$1.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug$1.skips.push(ns.slice(1));
			else createDebug$1.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable$1() {
			const namespaces = [...createDebug$1.names, ...createDebug$1.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug$1.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled$1(name) {
			for (const skip of createDebug$1.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug$1.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce$1(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug$1.enable(createDebug$1.load());
		return createDebug$1;
	}
	module.exports = setup;
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js
var require_node$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	const tty$1 = __require("tty");
	const util$2 = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init$2;
	exports.log = log$3;
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$2;
	exports.useColors = useColors$1;
	exports.destroy = util$2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor = __require("supports-color");
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error$1) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors$1() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$1.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		const { namespace: name, useColors: useColors$2 } = this;
		if (useColors$2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log$3(...args) {
		return process.stderr.write(util$2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$2() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init$2(debug$19) {
		debug$19.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i$1 = 0; i$1 < keys.length; i$1++) debug$19.inspectOpts[keys[i$1]] = exports.inspectOpts[keys[i$1]];
	}
	module.exports = require_common$1()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/esm/estree-walker.js
/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef {{
skip: () => void;
remove: () => void;
replace: (node: BaseNode) => void;
}} WalkerContext */
var WalkerBase$1 = class {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;
		/** @type {boolean} */
		this.should_remove = false;
		/** @type {BaseNode | null} */
		this.replacement = null;
		/** @type {WalkerContext} */
		this.context = {
			skip: () => this.should_skip = true,
			remove: () => this.should_remove = true,
			replace: (node) => this.replacement = node
		};
	}
	/**
	*
	* @param {any} parent
	* @param {string} prop
	* @param {number} index
	* @param {BaseNode} node
	*/
	replace(parent, prop, index, node) {
		if (parent) if (index !== null) parent[prop][index] = node;
		else parent[prop] = node;
	}
	/**
	*
	* @param {any} parent
	* @param {string} prop
	* @param {number} index
	*/
	remove(parent, prop, index) {
		if (parent) if (index !== null) parent[prop].splice(index, 1);
		else delete parent[prop];
	}
};
/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./walker.js').WalkerContext} WalkerContext */
/** @typedef {(
*    this: WalkerContext,
*    node: BaseNode,
*    parent: BaseNode,
*    key: string,
*    index: number
* ) => void} SyncHandler */
var SyncWalker$1 = class extends WalkerBase$1 {
	/**
	*
	* @param {SyncHandler} enter
	* @param {SyncHandler} leave
	*/
	constructor(enter, leave) {
		super();
		/** @type {SyncHandler} */
		this.enter = enter;
		/** @type {SyncHandler} */
		this.leave = leave;
	}
	/**
	*
	* @param {BaseNode} node
	* @param {BaseNode} parent
	* @param {string} [prop]
	* @param {number} [index]
	* @returns {BaseNode}
	*/
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;
				this.enter.call(this.context, node, parent, prop, index);
				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}
				if (this.should_remove) this.remove(parent, prop, index);
				const skipped = this.should_skip;
				const removed = this.should_remove;
				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;
				if (skipped) return node;
				if (removed) return null;
			}
			for (const key in node) {
				const value$1 = node[key];
				if (typeof value$1 !== "object") continue;
				else if (Array.isArray(value$1)) {
					for (let i$1 = 0; i$1 < value$1.length; i$1 += 1) if (value$1[i$1] !== null && typeof value$1[i$1].type === "string") {
						if (!this.visit(value$1[i$1], node, key, i$1)) i$1--;
					}
				} else if (value$1 !== null && typeof value$1.type === "string") this.visit(value$1, node, key, null);
			}
			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;
				this.leave.call(this.context, node, parent, prop, index);
				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}
				if (this.should_remove) this.remove(parent, prop, index);
				const removed = this.should_remove;
				this.replacement = _replacement;
				this.should_remove = _should_remove;
				if (removed) return null;
			}
		}
		return node;
	}
};
/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./sync.js').SyncHandler} SyncHandler */
/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */
/**
*
* @param {BaseNode} ast
* @param {{
*   enter?: SyncHandler
*   leave?: SyncHandler
* }} walker
* @returns {BaseNode}
*/
function walk$2(ast, { enter, leave }) {
	const instance = new SyncWalker$1(enter, leave);
	return instance.visit(ast, null);
}

//#endregion
//#region ../../node_modules/.pnpm/@rollup+pluginutils@5.2.0_rollup@4.43.0/node_modules/@rollup/pluginutils/dist/es/index.js
const extractors = {
	ArrayPattern(names, param) {
		for (const element of param.elements) if (element) extractors[element.type](names, element);
	},
	AssignmentPattern(names, param) {
		extractors[param.left.type](names, param.left);
	},
	Identifier(names, param) {
		names.push(param.name);
	},
	MemberExpression() {},
	ObjectPattern(names, param) {
		for (const prop of param.properties) if (prop.type === "RestElement") extractors.RestElement(names, prop);
		else extractors[prop.value.type](names, prop.value);
	},
	RestElement(names, param) {
		extractors[param.argument.type](names, param.argument);
	}
};
const extractAssignedNames = function extractAssignedNames$1(param) {
	const names = [];
	extractors[param.type](names, param);
	return names;
};
const blockDeclarations = {
	const: true,
	let: true
};
var Scope = class {
	constructor(options$1 = {}) {
		this.parent = options$1.parent;
		this.isBlockScope = !!options$1.block;
		this.declarations = Object.create(null);
		if (options$1.params) options$1.params.forEach((param) => {
			extractAssignedNames(param).forEach((name) => {
				this.declarations[name] = true;
			});
		});
	}
	addDeclaration(node, isBlockDeclaration, isVar) {
		if (!isBlockDeclaration && this.isBlockScope) this.parent.addDeclaration(node, isBlockDeclaration, isVar);
		else if (node.id) extractAssignedNames(node.id).forEach((name) => {
			this.declarations[name] = true;
		});
	}
	contains(name) {
		return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
	}
};
const attachScopes = function attachScopes$1(ast, propertyName = "scope") {
	let scope = new Scope();
	walk$2(ast, {
		enter(n$2, parent) {
			const node = n$2;
			if (/(?:Function|Class)Declaration/.test(node.type)) scope.addDeclaration(node, false, false);
			if (node.type === "VariableDeclaration") {
				const { kind } = node;
				const isBlockDeclaration = blockDeclarations[kind];
				node.declarations.forEach((declaration) => {
					scope.addDeclaration(declaration, isBlockDeclaration, true);
				});
			}
			let newScope;
			if (node.type.includes("Function")) {
				const func = node;
				newScope = new Scope({
					parent: scope,
					block: false,
					params: func.params
				});
				if (func.type === "FunctionExpression" && func.id) newScope.addDeclaration(func, false, false);
			}
			if (/For(?:In|Of)?Statement/.test(node.type)) newScope = new Scope({
				parent: scope,
				block: true
			});
			if (node.type === "BlockStatement" && !parent.type.includes("Function")) newScope = new Scope({
				parent: scope,
				block: true
			});
			if (node.type === "CatchClause") newScope = new Scope({
				parent: scope,
				params: node.param ? [node.param] : [],
				block: true
			});
			if (newScope) {
				Object.defineProperty(node, propertyName, {
					value: newScope,
					configurable: true
				});
				scope = newScope;
			}
		},
		leave(n$2) {
			const node = n$2;
			if (node[propertyName]) scope = scope.parent;
		}
	});
	return scope;
};
function isArray(arg) {
	return Array.isArray(arg);
}
function ensureArray(thing) {
	if (isArray(thing)) return thing;
	if (thing == null) return [];
	return [thing];
}
const normalizePathRegExp = new RegExp(`\\${win32.sep}`, "g");
const normalizePath$3 = function normalizePath$5(filename) {
	return filename.replace(normalizePathRegExp, posix$1.sep);
};
function getMatcherString$1(id, resolutionBase) {
	if (resolutionBase === false || isAbsolute$1(id) || id.startsWith("**")) return normalizePath$3(id);
	const basePath = normalizePath$3(resolve$1(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
	return posix$1.join(basePath, normalizePath$3(id));
}
const createFilter$2 = function createFilter$3(include, exclude, options$1) {
	const resolutionBase = options$1 && options$1.resolve;
	const getMatcher = (id) => id instanceof RegExp ? id : { test: (what) => {
		const pattern = getMatcherString$1(id, resolutionBase);
		const fn = picomatch(pattern, { dot: true });
		const result = fn(what);
		return result;
	} };
	const includeMatchers = ensureArray(include).map(getMatcher);
	const excludeMatchers = ensureArray(exclude).map(getMatcher);
	if (!includeMatchers.length && !excludeMatchers.length) return (id) => typeof id === "string" && !id.includes("\0");
	return function result(id) {
		if (typeof id !== "string") return false;
		if (id.includes("\0")) return false;
		const pathId = normalizePath$3(id);
		for (let i$1 = 0; i$1 < excludeMatchers.length; ++i$1) {
			const matcher = excludeMatchers[i$1];
			if (matcher instanceof RegExp) matcher.lastIndex = 0;
			if (matcher.test(pathId)) return false;
		}
		for (let i$1 = 0; i$1 < includeMatchers.length; ++i$1) {
			const matcher = includeMatchers[i$1];
			if (matcher instanceof RegExp) matcher.lastIndex = 0;
			if (matcher.test(pathId)) return true;
		}
		return !includeMatchers.length;
	};
};
const reservedWords = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
const builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
const forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(" "));
forbiddenIdentifiers.add("");
const makeLegalIdentifier = function makeLegalIdentifier$1(str) {
	let identifier = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
	if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) identifier = `_${identifier}`;
	return identifier || "_";
};
function stringify$4(obj) {
	return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
}
function serializeArray(arr, indent, baseIndent) {
	let output = "[";
	const separator = indent ? `\n${baseIndent}${indent}` : "";
	for (let i$1 = 0; i$1 < arr.length; i$1++) {
		const key = arr[i$1];
		output += `${i$1 > 0 ? "," : ""}${separator}${serialize(key, indent, baseIndent + indent)}`;
	}
	return `${output}${indent ? `\n${baseIndent}` : ""}]`;
}
function serializeObject(obj, indent, baseIndent) {
	let output = "{";
	const separator = indent ? `\n${baseIndent}${indent}` : "";
	const entries = Object.entries(obj);
	for (let i$1 = 0; i$1 < entries.length; i$1++) {
		const [key, value$1] = entries[i$1];
		const stringKey = makeLegalIdentifier(key) === key ? key : stringify$4(key);
		output += `${i$1 > 0 ? "," : ""}${separator}${stringKey}:${indent ? " " : ""}${serialize(value$1, indent, baseIndent + indent)}`;
	}
	return `${output}${indent ? `\n${baseIndent}` : ""}}`;
}
function serialize(obj, indent, baseIndent) {
	if (typeof obj === "object" && obj !== null) {
		if (Array.isArray(obj)) return serializeArray(obj, indent, baseIndent);
		if (obj instanceof Date) return `new Date(${obj.getTime()})`;
		if (obj instanceof RegExp) return obj.toString();
		return serializeObject(obj, indent, baseIndent);
	}
	if (typeof obj === "number") {
		if (obj === Infinity) return "Infinity";
		if (obj === -Infinity) return "-Infinity";
		if (obj === 0) return 1 / obj === Infinity ? "0" : "-0";
		if (obj !== obj) return "NaN";
	}
	if (typeof obj === "symbol") {
		const key = Symbol.keyFor(obj);
		if (key !== void 0) return `Symbol.for(${stringify$4(key)})`;
	}
	if (typeof obj === "bigint") return `${obj}n`;
	return stringify$4(obj);
}
const hasStringIsWellFormed = "isWellFormed" in String.prototype;
function isWellFormedString(input) {
	if (hasStringIsWellFormed) return input.isWellFormed();
	return !/\p{Surrogate}/u.test(input);
}
const dataToEsm = function dataToEsm$1(data, options$1 = {}) {
	var _a, _b;
	const t$1 = options$1.compact ? "" : "indent" in options$1 ? options$1.indent : "	";
	const _ = options$1.compact ? "" : " ";
	const n$2 = options$1.compact ? "" : "\n";
	const declarationType = options$1.preferConst ? "const" : "var";
	if (options$1.namedExports === false || typeof data !== "object" || Array.isArray(data) || data instanceof Date || data instanceof RegExp || data === null) {
		const code = serialize(data, options$1.compact ? null : t$1, "");
		const magic = _ || (/^[{[\-\/]/.test(code) ? "" : " ");
		return `export default${magic}${code};`;
	}
	let maxUnderbarPrefixLength = 0;
	for (const key of Object.keys(data)) {
		const underbarPrefixLength = (_b = (_a = /^(_+)/.exec(key)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0;
		if (underbarPrefixLength > maxUnderbarPrefixLength) maxUnderbarPrefixLength = underbarPrefixLength;
	}
	const arbitraryNamePrefix = `${"_".repeat(maxUnderbarPrefixLength + 1)}arbitrary`;
	let namedExportCode = "";
	const defaultExportRows = [];
	const arbitraryNameExportRows = [];
	for (const [key, value$1] of Object.entries(data)) if (key === makeLegalIdentifier(key)) {
		if (options$1.objectShorthand) defaultExportRows.push(key);
		else defaultExportRows.push(`${key}:${_}${key}`);
		namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value$1, options$1.compact ? null : t$1, "")};${n$2}`;
	} else {
		defaultExportRows.push(`${stringify$4(key)}:${_}${serialize(value$1, options$1.compact ? null : t$1, "")}`);
		if (options$1.includeArbitraryNames && isWellFormedString(key)) {
			const variableName = `${arbitraryNamePrefix}${arbitraryNameExportRows.length}`;
			namedExportCode += `${declarationType} ${variableName}${_}=${_}${serialize(value$1, options$1.compact ? null : t$1, "")};${n$2}`;
			arbitraryNameExportRows.push(`${variableName} as ${JSON.stringify(key)}`);
		}
	}
	const arbitraryExportCode = arbitraryNameExportRows.length > 0 ? `export${_}{${n$2}${t$1}${arbitraryNameExportRows.join(`,${n$2}${t$1}`)}${n$2}};${n$2}` : "";
	const defaultExportCode = `export default${_}{${n$2}${t$1}${defaultExportRows.join(`,${n$2}${t$1}`)}${n$2}};${n$2}`;
	return `${namedExportCode}${arbitraryExportCode}${defaultExportCode}`;
};

//#endregion
//#region src/node/packages.ts
let pnp;
if (process.versions.pnp) try {
	pnp = createRequire(
		/** #__KEEP__ */
		import.meta.url
	)("pnpapi");
} catch {}
function invalidatePackageData(packageCache, pkgPath) {
	const pkgDir = normalizePath(path.dirname(pkgPath));
	packageCache.forEach((pkg, cacheKey) => {
		if (pkg.dir === pkgDir) packageCache.delete(cacheKey);
	});
}
function resolvePackageData(pkgName, basedir, preserveSymlinks = false, packageCache) {
	if (pnp) {
		const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
		if (packageCache?.has(cacheKey)) return packageCache.get(cacheKey);
		try {
			const pkg = pnp.resolveToUnqualified(pkgName, basedir, { considerBuiltins: false });
			if (!pkg) return null;
			const pkgData = loadPackageData(path.join(pkg, "package.json"));
			packageCache?.set(cacheKey, pkgData);
			return pkgData;
		} catch {
			return null;
		}
	}
	const originalBasedir = basedir;
	while (basedir) {
		if (packageCache) {
			const cached = getRpdCache(packageCache, pkgName, basedir, originalBasedir, preserveSymlinks);
			if (cached) return cached;
		}
		const pkg = path.join(basedir, "node_modules", pkgName, "package.json");
		try {
			if (fs.existsSync(pkg)) {
				const pkgPath = preserveSymlinks ? pkg : safeRealpathSync(pkg);
				const pkgData = loadPackageData(pkgPath);
				if (packageCache) setRpdCache(packageCache, pkgData, pkgName, basedir, originalBasedir, preserveSymlinks);
				return pkgData;
			}
		} catch {}
		const nextBasedir = path.dirname(basedir);
		if (nextBasedir === basedir) break;
		basedir = nextBasedir;
	}
	return null;
}
function findNearestPackageData(basedir, packageCache) {
	const originalBasedir = basedir;
	while (basedir) {
		if (packageCache) {
			const cached = getFnpdCache(packageCache, basedir, originalBasedir);
			if (cached) return cached;
		}
		const pkgPath = path.join(basedir, "package.json");
		if (tryStatSync(pkgPath)?.isFile()) try {
			const pkgData = loadPackageData(pkgPath);
			if (packageCache) setFnpdCache(packageCache, pkgData, basedir, originalBasedir);
			return pkgData;
		} catch {}
		const nextBasedir = path.dirname(basedir);
		if (nextBasedir === basedir) break;
		basedir = nextBasedir;
	}
	return null;
}
function findNearestMainPackageData(basedir, packageCache) {
	const nearestPackage = findNearestPackageData(basedir, packageCache);
	return nearestPackage && (nearestPackage.data.name ? nearestPackage : findNearestMainPackageData(path.dirname(nearestPackage.dir), packageCache));
}
function loadPackageData(pkgPath) {
	const data = JSON.parse(stripBomTag(fs.readFileSync(pkgPath, "utf-8")));
	const pkgDir = normalizePath(path.dirname(pkgPath));
	const { sideEffects } = data;
	let hasSideEffects;
	if (typeof sideEffects === "boolean") hasSideEffects = () => sideEffects;
	else if (Array.isArray(sideEffects)) if (sideEffects.length <= 0) hasSideEffects = () => false;
	else {
		const finalPackageSideEffects = sideEffects.map((sideEffect) => {
			if (sideEffect.includes("/")) return sideEffect;
			return `**/${sideEffect}`;
		});
		hasSideEffects = createFilter(finalPackageSideEffects, null, { resolve: pkgDir });
	}
	else hasSideEffects = () => null;
	const resolvedCache = {};
	const pkg = {
		dir: pkgDir,
		data,
		hasSideEffects,
		setResolvedCache(key, entry, options$1) {
			resolvedCache[getResolveCacheKey(key, options$1)] = entry;
		},
		getResolvedCache(key, options$1) {
			return resolvedCache[getResolveCacheKey(key, options$1)];
		}
	};
	return pkg;
}
function getResolveCacheKey(key, options$1) {
	return [
		key,
		options$1.isRequire ? "1" : "0",
		options$1.conditions.join("_"),
		options$1.extensions.join("_"),
		options$1.mainFields.join("_")
	].join("|");
}
function findNearestNodeModules(basedir) {
	while (basedir) {
		const pkgPath = path.join(basedir, "node_modules");
		if (tryStatSync(pkgPath)?.isDirectory()) return pkgPath;
		const nextBasedir = path.dirname(basedir);
		if (nextBasedir === basedir) break;
		basedir = nextBasedir;
	}
	return null;
}
function watchPackageDataPlugin(packageCache) {
	const watchQueue = /* @__PURE__ */ new Set();
	const watchedDirs = /* @__PURE__ */ new Set();
	const watchFileStub = (id) => {
		watchQueue.add(id);
	};
	let watchFile = watchFileStub;
	const setPackageData = packageCache.set.bind(packageCache);
	packageCache.set = (id, pkg) => {
		if (!isInNodeModules(pkg.dir) && !watchedDirs.has(pkg.dir)) {
			watchedDirs.add(pkg.dir);
			watchFile(path.join(pkg.dir, "package.json"));
		}
		return setPackageData(id, pkg);
	};
	return {
		name: "vite:watch-package-data",
		buildStart() {
			watchFile = this.addWatchFile.bind(this);
			watchQueue.forEach(watchFile);
			watchQueue.clear();
		},
		buildEnd() {
			watchFile = watchFileStub;
		},
		watchChange(id) {
			if (id.endsWith("/package.json")) invalidatePackageData(packageCache, path.normalize(id));
		}
	};
}
/**
* Get cached `resolvePackageData` value based on `basedir`. When one is found,
* and we've already traversed some directories between `basedir` and `originalBasedir`,
* we cache the value for those in-between directories as well.
*
* This makes it so the fs is only read once for a shared `basedir`.
*/
function getRpdCache(packageCache, pkgName, basedir, originalBasedir, preserveSymlinks) {
	const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
	const pkgData = packageCache.get(cacheKey);
	if (pkgData) {
		traverseBetweenDirs(originalBasedir, basedir, (dir) => {
			packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
		});
		return pkgData;
	}
}
function setRpdCache(packageCache, pkgData, pkgName, basedir, originalBasedir, preserveSymlinks) {
	packageCache.set(getRpdCacheKey(pkgName, basedir, preserveSymlinks), pkgData);
	traverseBetweenDirs(originalBasedir, basedir, (dir) => {
		packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
	});
}
function getRpdCacheKey(pkgName, basedir, preserveSymlinks) {
	return `rpd_${pkgName}_${basedir}_${preserveSymlinks}`;
}
/**
* Get cached `findNearestPackageData` value based on `basedir`. When one is found,
* and we've already traversed some directories between `basedir` and `originalBasedir`,
* we cache the value for those in-between directories as well.
*
* This makes it so the fs is only read once for a shared `basedir`.
*/
function getFnpdCache(packageCache, basedir, originalBasedir) {
	const cacheKey = getFnpdCacheKey(basedir);
	const pkgData = packageCache.get(cacheKey);
	if (pkgData) {
		traverseBetweenDirs(originalBasedir, basedir, (dir) => {
			packageCache.set(getFnpdCacheKey(dir), pkgData);
		});
		return pkgData;
	}
}
function setFnpdCache(packageCache, pkgData, basedir, originalBasedir) {
	packageCache.set(getFnpdCacheKey(basedir), pkgData);
	traverseBetweenDirs(originalBasedir, basedir, (dir) => {
		packageCache.set(getFnpdCacheKey(dir), pkgData);
	});
}
function getFnpdCacheKey(basedir) {
	return `fnpd_${basedir}`;
}
/**
* Traverse between `longerDir` (inclusive) and `shorterDir` (exclusive) and call `cb` for each dir.
* @param longerDir Longer dir path, e.g. `/User/foo/bar/baz`
* @param shorterDir Shorter dir path, e.g. `/User/foo`
*/
function traverseBetweenDirs(longerDir, shorterDir, cb) {
	while (longerDir !== shorterDir) {
		cb(longerDir);
		longerDir = path.dirname(longerDir);
	}
}

//#endregion
//#region src/node/utils.ts
var import_picocolors$33 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var import_node = /* @__PURE__ */ __toESM(require_node$1(), 1);
const createFilter = createFilter$2;
const replaceSlashOrColonRE = /[/:]/g;
const replaceDotRE = /\./g;
const replaceNestedIdRE = /\s*>\s*/g;
const replaceHashRE = /#/g;
const flattenId = (id) => {
	const flatId = limitFlattenIdLength(id.replace(replaceSlashOrColonRE, "_").replace(replaceDotRE, "__").replace(replaceNestedIdRE, "___").replace(replaceHashRE, "____"));
	return flatId;
};
const FLATTEN_ID_HASH_LENGTH = 8;
const FLATTEN_ID_MAX_FILE_LENGTH = 170;
const limitFlattenIdLength = (id, limit = FLATTEN_ID_MAX_FILE_LENGTH) => {
	if (id.length <= limit) return id;
	return id.slice(0, limit - (FLATTEN_ID_HASH_LENGTH + 1)) + "_" + getHash(id);
};
const normalizeId = (id) => id.replace(replaceNestedIdRE, " > ");
const NODE_BUILTIN_NAMESPACE = "node:";
const BUN_BUILTIN_NAMESPACE = "bun:";
const nodeBuiltins = builtinModules.filter((id) => !id.includes(":"));
const isBuiltinCache = /* @__PURE__ */ new WeakMap();
function isBuiltin(builtins$1, id) {
	let isBuiltin$1 = isBuiltinCache.get(builtins$1);
	if (!isBuiltin$1) {
		isBuiltin$1 = createIsBuiltin(builtins$1);
		isBuiltinCache.set(builtins$1, isBuiltin$1);
	}
	return isBuiltin$1(id);
}
function createIsBuiltin(builtins$1) {
	const plainBuiltinsSet = new Set(builtins$1.filter((builtin) => typeof builtin === "string"));
	const regexBuiltins = builtins$1.filter((builtin) => typeof builtin !== "string");
	return (id) => plainBuiltinsSet.has(id) || regexBuiltins.some((regexp) => regexp.test(id));
}
const nodeLikeBuiltins = [
	...nodeBuiltins,
	/* @__PURE__ */ new RegExp(`^${NODE_BUILTIN_NAMESPACE}`),
	/* @__PURE__ */ new RegExp(`^${BUN_BUILTIN_NAMESPACE}`)
];
function isNodeLikeBuiltin(id) {
	return isBuiltin(nodeLikeBuiltins, id);
}
function isNodeBuiltin(id) {
	if (id.startsWith(NODE_BUILTIN_NAMESPACE)) return true;
	return nodeBuiltins.includes(id);
}
function isInNodeModules(id) {
	return id.includes("node_modules");
}
function moduleListContains(moduleList, id) {
	return moduleList?.some((m$2) => m$2 === id || id.startsWith(withTrailingSlash(m$2)));
}
function isOptimizable(id, optimizeDeps$1) {
	const { extensions: extensions$1 } = optimizeDeps$1;
	return OPTIMIZABLE_ENTRY_RE.test(id) || (extensions$1?.some((ext) => id.endsWith(ext)) ?? false);
}
const bareImportRE = /^(?![a-zA-Z]:)[\w@](?!.*:\/\/)/;
const deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//;
const _require$1 = createRequire(
	/** #__KEEP__ */
	import.meta.url
);
const _dirname = path.dirname(fileURLToPath(
	/** #__KEEP__ */
	import.meta.url
));
const rollupVersion = resolvePackageData("rollup", _dirname, true)?.data.version ?? "";
const filter = process.env.VITE_DEBUG_FILTER;
const DEBUG = process.env.DEBUG;
function createDebugger(namespace, options$1 = {}) {
	const log$4 = (0, import_node.default)(namespace);
	const { onlyWhenFocused, depth } = options$1;
	if (depth && log$4.inspectOpts && log$4.inspectOpts.depth == null) log$4.inspectOpts.depth = options$1.depth;
	let enabled$1 = log$4.enabled;
	if (enabled$1 && onlyWhenFocused) {
		const ns = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
		enabled$1 = !!DEBUG?.includes(ns);
	}
	if (enabled$1) return (...args) => {
		if (!filter || args.some((a) => a?.includes?.(filter))) log$4(...args);
	};
}
function testCaseInsensitiveFS() {
	if (!CLIENT_ENTRY.endsWith("client.mjs")) throw new Error(`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`);
	if (!fs.existsSync(CLIENT_ENTRY)) throw new Error("cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY);
	return fs.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
const isCaseInsensitiveFS = testCaseInsensitiveFS();
const VOLUME_RE = /^[A-Z]:/i;
function normalizePath(id) {
	return path.posix.normalize(isWindows ? slash(id) : id);
}
function fsPathFromId(id) {
	const fsPath = normalizePath(id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id);
	return fsPath[0] === "/" || VOLUME_RE.test(fsPath) ? fsPath : `/${fsPath}`;
}
function fsPathFromUrl(url$3) {
	return fsPathFromId(cleanUrl(url$3));
}
/**
* Check if dir is a parent of file
*
* Warning: parameters are not validated, only works with normalized absolute paths
*
* @param dir - normalized absolute path
* @param file - normalized absolute path
* @returns true if dir is a parent of file
*/
function isParentDirectory(dir, file) {
	dir = withTrailingSlash(dir);
	return file.startsWith(dir) || isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase());
}
/**
* Check if 2 file name are identical
*
* Warning: parameters are not validated, only works with normalized absolute paths
*
* @param file1 - normalized absolute path
* @param file2 - normalized absolute path
* @returns true if both files url are identical
*/
function isSameFilePath(file1, file2) {
	return file1 === file2 || isCaseInsensitiveFS && file1.toLowerCase() === file2.toLowerCase();
}
const externalRE = /^([a-z]+:)?\/\//;
const isExternalUrl = (url$3) => externalRE.test(url$3);
const dataUrlRE = /^\s*data:/i;
const isDataUrl = (url$3) => dataUrlRE.test(url$3);
const virtualModuleRE = /^virtual-module:.*/;
const virtualModulePrefix = "virtual-module:";
const knownJsSrcRE = /\.(?:[jt]sx?|m[jt]s|vue|marko|svelte|astro|imba|mdx)(?:$|\?)/;
const isJSRequest = (url$3) => {
	url$3 = cleanUrl(url$3);
	if (knownJsSrcRE.test(url$3)) return true;
	if (!path.extname(url$3) && url$3[url$3.length - 1] !== "/") return true;
	return false;
};
const isCSSRequest = (request) => CSS_LANGS_RE.test(request);
const importQueryRE = /(\?|&)import=?(?:&|$)/;
const directRequestRE$1 = /(\?|&)direct=?(?:&|$)/;
const internalPrefixes = [
	FS_PREFIX,
	VALID_ID_PREFIX,
	CLIENT_PUBLIC_PATH,
	ENV_PUBLIC_PATH
];
const InternalPrefixRE = /* @__PURE__ */ new RegExp(`^(?:${internalPrefixes.join("|")})`);
const trailingSeparatorRE = /[?&]$/;
const isImportRequest = (url$3) => importQueryRE.test(url$3);
const isInternalRequest = (url$3) => InternalPrefixRE.test(url$3);
function removeImportQuery(url$3) {
	return url$3.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
}
function removeDirectQuery(url$3) {
	return url$3.replace(directRequestRE$1, "$1").replace(trailingSeparatorRE, "");
}
const urlRE = /(\?|&)url(?:&|$)/;
const rawRE = /(\?|&)raw(?:&|$)/;
function removeUrlQuery(url$3) {
	return url$3.replace(urlRE, "$1").replace(trailingSeparatorRE, "");
}
function injectQuery(url$3, queryToInject) {
	const { file, postfix } = splitFileAndPostfix(url$3);
	const normalizedFile = isWindows ? slash(file) : file;
	return `${normalizedFile}?${queryToInject}${postfix[0] === "?" ? `&${postfix.slice(1)}` : postfix}`;
}
const timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url$3) {
	return url$3.replace(timestampRE, "").replace(trailingSeparatorRE, "");
}
async function asyncReplace(input, re, replacer) {
	let match;
	let remaining = input;
	let rewritten = "";
	while (match = re.exec(remaining)) {
		rewritten += remaining.slice(0, match.index);
		rewritten += await replacer(match);
		remaining = remaining.slice(match.index + match[0].length);
	}
	rewritten += remaining;
	return rewritten;
}
function timeFrom(start, subtract = 0) {
	const time = performance$1.now() - start - subtract;
	const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
	if (time < 10) return import_picocolors$33.default.green(timeString);
	else if (time < 50) return import_picocolors$33.default.yellow(timeString);
	else return import_picocolors$33.default.red(timeString);
}
/**
* pretty url for logging.
*/
function prettifyUrl(url$3, root) {
	url$3 = removeTimestampQuery(url$3);
	const isAbsoluteFile = url$3.startsWith(root);
	if (isAbsoluteFile || url$3.startsWith(FS_PREFIX)) {
		const file = path.posix.relative(root, isAbsoluteFile ? url$3 : fsPathFromId(url$3));
		return import_picocolors$33.default.dim(file);
	} else return import_picocolors$33.default.dim(url$3);
}
function isObject(value$1) {
	return Object.prototype.toString.call(value$1) === "[object Object]";
}
function isDefined(value$1) {
	return value$1 != null;
}
function tryStatSync(file) {
	try {
		return fs.statSync(file, { throwIfNoEntry: false });
	} catch {}
}
function lookupFile(dir, fileNames) {
	while (dir) {
		for (const fileName of fileNames) {
			const fullPath = path.join(dir, fileName);
			if (tryStatSync(fullPath)?.isFile()) return fullPath;
		}
		const parentDir$1 = path.dirname(dir);
		if (parentDir$1 === dir) return;
		dir = parentDir$1;
	}
}
function isFilePathESM(filePath, packageCache) {
	if (/\.m[jt]s$/.test(filePath)) return true;
	else if (/\.c[jt]s$/.test(filePath)) return false;
	else try {
		const pkg = findNearestPackageData(path.dirname(filePath), packageCache);
		return pkg?.data.type === "module";
	} catch {
		return false;
	}
}
const splitRE = /\r?\n/g;
const range = 2;
function pad$1(source, n$2 = 2) {
	const lines = source.split(splitRE);
	return lines.map((l) => ` `.repeat(n$2) + l).join(`\n`);
}
function posToNumber(source, pos) {
	if (typeof pos === "number") return pos;
	const lines = source.split(splitRE);
	const { line, column } = pos;
	let start = 0;
	for (let i$1 = 0; i$1 < line - 1 && i$1 < lines.length; i$1++) start += lines[i$1].length + 1;
	return start + column;
}
function numberToPos(source, offset$1) {
	if (typeof offset$1 !== "number") return offset$1;
	if (offset$1 > source.length) throw new Error(`offset is longer than source length! offset ${offset$1} > length ${source.length}`);
	const lines = source.slice(0, offset$1).split(splitRE);
	return {
		line: lines.length,
		column: lines[lines.length - 1].length
	};
}
const MAX_DISPLAY_LEN = 120;
const ELLIPSIS = "...";
function generateCodeFrame(source, start = 0, end) {
	start = Math.max(posToNumber(source, start), 0);
	end = Math.min(end !== void 0 ? posToNumber(source, end) : start, source.length);
	const lastPosLine = end !== void 0 ? numberToPos(source, end).line : numberToPos(source, start).line + range;
	const lineNumberWidth = Math.max(3, String(lastPosLine).length + 1);
	const lines = source.split(splitRE);
	let count = 0;
	const res = [];
	for (let i$1 = 0; i$1 < lines.length; i$1++) {
		count += lines[i$1].length;
		if (count >= start) {
			for (let j = i$1 - range; j <= i$1 + range || end > count; j++) {
				if (j < 0 || j >= lines.length) continue;
				const line = j + 1;
				const lineLength = lines[j].length;
				const pad$2 = Math.max(start - (count - lineLength), 0);
				const underlineLength = Math.max(1, end > count ? lineLength - pad$2 : end - start);
				let displayLine = lines[j];
				let underlinePad = pad$2;
				if (lineLength > MAX_DISPLAY_LEN) {
					let startIdx = 0;
					if (j === i$1) {
						if (underlineLength > MAX_DISPLAY_LEN) startIdx = pad$2;
						else {
							const center = pad$2 + Math.floor(underlineLength / 2);
							startIdx = Math.max(0, center - Math.floor(MAX_DISPLAY_LEN / 2));
						}
						underlinePad = Math.max(0, pad$2 - startIdx) + (startIdx > 0 ? 3 : 0);
					}
					const prefix = startIdx > 0 ? ELLIPSIS : "";
					const suffix = lineLength - startIdx > MAX_DISPLAY_LEN ? ELLIPSIS : "";
					const sliceLen = MAX_DISPLAY_LEN - prefix.length - suffix.length;
					displayLine = prefix + displayLine.slice(startIdx, startIdx + sliceLen) + suffix;
				}
				res.push(`${line}${" ".repeat(lineNumberWidth - String(line).length)}|  ${displayLine}`);
				if (j === i$1) {
					const underline = "^".repeat(Math.min(underlineLength, MAX_DISPLAY_LEN));
					res.push(`${" ".repeat(lineNumberWidth)}|  ` + " ".repeat(underlinePad) + underline);
				} else if (j > i$1) {
					if (end > count) {
						const length = Math.max(Math.min(end - count, lineLength), 1);
						const underline = "^".repeat(Math.min(length, MAX_DISPLAY_LEN));
						res.push(`${" ".repeat(lineNumberWidth)}|  ` + underline);
					}
					count += lineLength + 1;
				}
			}
			break;
		}
		count++;
	}
	return res.join("\n");
}
function isFileReadable(filename) {
	if (!tryStatSync(filename)) return false;
	try {
		fs.accessSync(filename, fs.constants.R_OK);
		return true;
	} catch {
		return false;
	}
}
const splitFirstDirRE = /(.+?)[\\/](.+)/;
/**
* Delete every file and subdirectory. **The given directory must exist.**
* Pass an optional `skip` array to preserve files under the root directory.
*/
function emptyDir(dir, skip) {
	const skipInDir = [];
	let nested = null;
	if (skip?.length) for (const file of skip) if (path.dirname(file) !== ".") {
		const matched = splitFirstDirRE.exec(file);
		if (matched) {
			nested ??= /* @__PURE__ */ new Map();
			const [, nestedDir, skipPath] = matched;
			let nestedSkip = nested.get(nestedDir);
			if (!nestedSkip) {
				nestedSkip = [];
				nested.set(nestedDir, nestedSkip);
			}
			if (!nestedSkip.includes(skipPath)) nestedSkip.push(skipPath);
		}
	} else skipInDir.push(file);
	for (const file of fs.readdirSync(dir)) {
		if (skipInDir.includes(file)) continue;
		if (nested?.has(file)) emptyDir(path.resolve(dir, file), nested.get(file));
		else fs.rmSync(path.resolve(dir, file), {
			recursive: true,
			force: true
		});
	}
}
function copyDir(srcDir, destDir) {
	fs.mkdirSync(destDir, { recursive: true });
	for (const file of fs.readdirSync(srcDir)) {
		const srcFile = path.resolve(srcDir, file);
		if (srcFile === destDir) continue;
		const destFile = path.resolve(destDir, file);
		const stat$4 = fs.statSync(srcFile);
		if (stat$4.isDirectory()) copyDir(srcFile, destFile);
		else fs.copyFileSync(srcFile, destFile);
	}
}
const ERR_SYMLINK_IN_RECURSIVE_READDIR = "ERR_SYMLINK_IN_RECURSIVE_READDIR";
async function recursiveReaddir(dir) {
	if (!fs.existsSync(dir)) return [];
	let dirents;
	try {
		dirents = await fsp.readdir(dir, { withFileTypes: true });
	} catch (e$1) {
		if (e$1.code === "EACCES") return [];
		throw e$1;
	}
	if (dirents.some((dirent) => dirent.isSymbolicLink())) {
		const err$2 = /* @__PURE__ */ new Error("Symbolic links are not supported in recursiveReaddir");
		err$2.code = ERR_SYMLINK_IN_RECURSIVE_READDIR;
		throw err$2;
	}
	const files = await Promise.all(dirents.map((dirent) => {
		const res = path.resolve(dir, dirent.name);
		return dirent.isDirectory() ? recursiveReaddir(res) : normalizePath(res);
	}));
	return files.flat(1);
}
let safeRealpathSync = isWindows ? windowsSafeRealPathSync : fs.realpathSync.native;
const windowsNetworkMap = /* @__PURE__ */ new Map();
function windowsMappedRealpathSync(path$13) {
	const realPath = fs.realpathSync.native(path$13);
	if (realPath.startsWith("\\\\")) {
		for (const [network, volume] of windowsNetworkMap) if (realPath.startsWith(network)) return realPath.replace(network, volume);
	}
	return realPath;
}
const parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/;
let firstSafeRealPathSyncRun = false;
function windowsSafeRealPathSync(path$13) {
	if (!firstSafeRealPathSyncRun) {
		optimizeSafeRealPathSync();
		firstSafeRealPathSyncRun = true;
	}
	return fs.realpathSync(path$13);
}
function optimizeSafeRealPathSync() {
	try {
		fs.realpathSync.native(path.resolve("./"));
	} catch (error$1) {
		if (error$1.message.includes("EISDIR: illegal operation on a directory")) {
			safeRealpathSync = fs.realpathSync;
			return;
		}
	}
	exec("net use", (error$1, stdout) => {
		if (error$1) return;
		const lines = stdout.split("\n");
		for (const line of lines) {
			const m$2 = parseNetUseRE.exec(line);
			if (m$2) windowsNetworkMap.set(m$2[2], m$2[1]);
		}
		if (windowsNetworkMap.size === 0) safeRealpathSync = fs.realpathSync.native;
		else safeRealpathSync = windowsMappedRealpathSync;
	});
}
function ensureWatchedFile(watcher, file, root) {
	if (file && !file.startsWith(withTrailingSlash(root)) && !file.includes("\0") && fs.existsSync(file)) watcher.add(path.resolve(file));
}
function joinSrcset(ret) {
	return ret.map(({ url: url$3, descriptor }) => url$3 + (descriptor ? ` ${descriptor}` : "")).join(", ");
}
/**
This regex represents a loose rule of an “image candidate string” and "image set options".

@see https://html.spec.whatwg.org/multipage/images.html#srcset-attribute
@see https://drafts.csswg.org/css-images-4/#image-set-notation

The Regex has named capturing groups `url` and `descriptor`.
The `url` group can be:
* any CSS function
* CSS string (single or double-quoted)
* URL string (unquoted)
The `descriptor` is anything after the space and before the comma.
*/
const imageCandidateRegex = /(?:^|\s|(?<=,))(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g;
const escapedSpaceCharacters = /(?: |\\t|\\n|\\f|\\r)+/g;
function parseSrcset(string) {
	const matches$2 = string.trim().replace(escapedSpaceCharacters, " ").replace(/\r?\n/, "").replace(/,\s+/, ", ").replaceAll(/\s+/g, " ").matchAll(imageCandidateRegex);
	return Array.from(matches$2, ({ groups: groups$1 }) => ({
		url: groups$1?.url?.trim() ?? "",
		descriptor: groups$1?.descriptor?.trim() ?? ""
	})).filter(({ url: url$3 }) => !!url$3);
}
function processSrcSet(srcs, replacer) {
	return Promise.all(parseSrcset(srcs).map(async ({ url: url$3, descriptor }) => ({
		url: await replacer({
			url: url$3,
			descriptor
		}),
		descriptor
	}))).then(joinSrcset);
}
function processSrcSetSync(srcs, replacer) {
	return joinSrcset(parseSrcset(srcs).map(({ url: url$3, descriptor }) => ({
		url: replacer({
			url: url$3,
			descriptor
		}),
		descriptor
	})));
}
const windowsDriveRE = /^[A-Z]:/;
const replaceWindowsDriveRE = /^([A-Z]):\//;
const linuxAbsolutePathRE = /^\/[^/]/;
function escapeToLinuxLikePath(path$13) {
	if (windowsDriveRE.test(path$13)) return path$13.replace(replaceWindowsDriveRE, "/windows/$1/");
	if (linuxAbsolutePathRE.test(path$13)) return `/linux${path$13}`;
	return path$13;
}
const revertWindowsDriveRE = /^\/windows\/([A-Z])\//;
function unescapeToLinuxLikePath(path$13) {
	if (path$13.startsWith("/linux/")) return path$13.slice(6);
	if (path$13.startsWith("/windows/")) return path$13.replace(revertWindowsDriveRE, "$1:/");
	return path$13;
}
const nullSourceMap = {
	names: [],
	sources: [],
	mappings: "",
	version: 3
};
/**
* Combines multiple sourcemaps into a single sourcemap.
* Note that the length of sourcemapList must be 2.
*/
function combineSourcemaps(filename, sourcemapList) {
	if (sourcemapList.length === 0 || sourcemapList.every((m$2) => m$2.sources.length === 0)) return { ...nullSourceMap };
	sourcemapList = sourcemapList.map((sourcemap) => {
		const newSourcemaps = { ...sourcemap };
		newSourcemaps.sources = sourcemap.sources.map((source) => source ? escapeToLinuxLikePath(source) : null);
		if (sourcemap.sourceRoot) newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot);
		return newSourcemaps;
	});
	const escapedFilename = escapeToLinuxLikePath(filename);
	let map$1;
	let mapIndex = 1;
	const useArrayInterface = sourcemapList.slice(0, -1).find((m$2) => m$2.sources.length !== 1) === void 0;
	if (useArrayInterface) map$1 = remapping(sourcemapList, () => null);
	else map$1 = remapping(sourcemapList[0], function loader$1(sourcefile) {
		if (sourcefile === escapedFilename && sourcemapList[mapIndex]) return sourcemapList[mapIndex++];
		else return null;
	});
	if (!map$1.file) delete map$1.file;
	map$1.sources = map$1.sources.map((source) => source ? unescapeToLinuxLikePath(source) : source);
	map$1.file = filename;
	return map$1;
}
function unique(arr) {
	return Array.from(new Set(arr));
}
/**
* Returns resolved localhost address when `dns.lookup` result differs from DNS
*
* `dns.lookup` result is same when defaultResultOrder is `verbatim`.
* Even if defaultResultOrder is `ipv4first`, `dns.lookup` result maybe same.
* For example, when IPv6 is not supported on that machine/network.
*/
async function getLocalhostAddressIfDiffersFromDNS() {
	const [nodeResult, dnsResult] = await Promise.all([promises$1.lookup("localhost"), promises$1.lookup("localhost", { verbatim: true })]);
	const isSame = nodeResult.family === dnsResult.family && nodeResult.address === dnsResult.address;
	return isSame ? void 0 : nodeResult.address;
}
function diffDnsOrderChange(oldUrls, newUrls) {
	return !(oldUrls === newUrls || oldUrls && newUrls && arrayEqual(oldUrls.local, newUrls.local) && arrayEqual(oldUrls.network, newUrls.network));
}
async function resolveHostname(optionsHost) {
	let host;
	if (optionsHost === void 0 || optionsHost === false) host = "localhost";
	else if (optionsHost === true) host = void 0;
	else host = optionsHost;
	let name = host === void 0 || wildcardHosts.has(host) ? "localhost" : host;
	if (host === "localhost") {
		const localhostAddr = await getLocalhostAddressIfDiffersFromDNS();
		if (localhostAddr) name = localhostAddr;
	}
	return {
		host,
		name
	};
}
function resolveServerUrls(server, options$1, hostname, httpsOptions, config$2) {
	const address = server.address();
	const isAddressInfo = (x) => x?.address;
	if (!isAddressInfo(address)) return {
		local: [],
		network: []
	};
	const local = [];
	const network = [];
	const protocol = options$1.https ? "https" : "http";
	const port = address.port;
	const base = config$2.rawBase === "./" || config$2.rawBase === "" ? "/" : config$2.rawBase;
	if (hostname.host !== void 0 && !wildcardHosts.has(hostname.host)) {
		let hostnameName = hostname.name;
		if (hostnameName.includes(":")) hostnameName = `[${hostnameName}]`;
		const address$1 = `${protocol}://${hostnameName}:${port}${base}`;
		if (loopbackHosts.has(hostname.host)) local.push(address$1);
		else network.push(address$1);
	} else Object.values(os.networkInterfaces()).flatMap((nInterface) => nInterface ?? []).filter((detail) => detail.address && detail.family === "IPv4").forEach((detail) => {
		let host = detail.address.replace("127.0.0.1", hostname.name);
		if (host.includes(":")) host = `[${host}]`;
		const url$3 = `${protocol}://${host}:${port}${base}`;
		if (detail.address.includes("127.0.0.1")) local.push(url$3);
		else network.push(url$3);
	});
	const cert = httpsOptions?.cert && !Array.isArray(httpsOptions.cert) ? new crypto.X509Certificate(httpsOptions.cert) : void 0;
	const hostnameFromCert = cert?.subjectAltName ? extractHostnamesFromSubjectAltName(cert.subjectAltName) : [];
	if (hostnameFromCert.length > 0) {
		const existings = new Set([...local, ...network]);
		local.push(...hostnameFromCert.map((hostname$1) => `https://${hostname$1}:${port}${base}`).filter((url$3) => !existings.has(url$3)));
	}
	return {
		local,
		network
	};
}
function extractHostnamesFromSubjectAltName(subjectAltName) {
	const hostnames = [];
	let remaining = subjectAltName;
	while (remaining) {
		const nameEndIndex = remaining.indexOf(":");
		const name = remaining.slice(0, nameEndIndex);
		remaining = remaining.slice(nameEndIndex + 1);
		if (!remaining) break;
		const isQuoted = remaining[0] === "\"";
		let value$1;
		if (isQuoted) {
			const endQuoteIndex = remaining.indexOf("\"", 1);
			value$1 = JSON.parse(remaining.slice(0, endQuoteIndex + 1));
			remaining = remaining.slice(endQuoteIndex + 1);
		} else {
			const maybeEndIndex = remaining.indexOf(",");
			const endIndex = maybeEndIndex === -1 ? remaining.length : maybeEndIndex;
			value$1 = remaining.slice(0, endIndex);
			remaining = remaining.slice(endIndex);
		}
		remaining = remaining.slice(1).trimStart();
		if (name === "DNS" && value$1 !== "[::1]" && !(value$1.startsWith("*.") && net.isIPv4(value$1.slice(2)))) hostnames.push(value$1.replace("*", "vite"));
	}
	return hostnames;
}
function arraify(target) {
	return Array.isArray(target) ? target : [target];
}
const multilineCommentsRE = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g;
const singlelineCommentsRE = /\/\/.*/g;
const requestQuerySplitRE = /\?(?!.*[/|}])/;
const requestQueryMaybeEscapedSplitRE = /\\?\?(?!.*[/|}])/;
const blankReplacer = (match) => " ".repeat(match.length);
function getHash(text, length = 8) {
	const h$2 = crypto.hash("sha256", text, "hex").substring(0, length);
	if (length <= 64) return h$2;
	return h$2.padEnd(length, "_");
}
const requireResolveFromRootWithFallback = (root, id) => {
	const found$1 = resolvePackageData(id, root) || resolvePackageData(id, _dirname);
	if (!found$1) {
		const error$1 = /* @__PURE__ */ new Error(`${JSON.stringify(id)} not found.`);
		error$1.code = "MODULE_NOT_FOUND";
		throw error$1;
	}
	return _require$1.resolve(id, { paths: [root, _dirname] });
};
function emptyCssComments(raw) {
	return raw.replace(multilineCommentsRE, blankReplacer);
}
function backwardCompatibleWorkerPlugins(plugins$1) {
	if (Array.isArray(plugins$1)) return plugins$1;
	if (typeof plugins$1 === "function") return plugins$1();
	return [];
}
function deepClone(value$1) {
	if (Array.isArray(value$1)) return value$1.map((v) => deepClone(v));
	if (isObject(value$1)) {
		const cloned = {};
		for (const key in value$1) cloned[key] = deepClone(value$1[key]);
		return cloned;
	}
	if (typeof value$1 === "function") return value$1;
	if (value$1 instanceof RegExp) return new RegExp(value$1);
	if (typeof value$1 === "object" && value$1 != null) throw new Error("Cannot deep clone non-plain object");
	return value$1;
}
function mergeWithDefaultsRecursively(defaults, values) {
	const merged = defaults;
	for (const key in values) {
		const value$1 = values[key];
		if (value$1 === void 0) continue;
		const existing = merged[key];
		if (existing === void 0) {
			merged[key] = value$1;
			continue;
		}
		if (isObject(existing) && isObject(value$1)) {
			merged[key] = mergeWithDefaultsRecursively(existing, value$1);
			continue;
		}
		merged[key] = value$1;
	}
	return merged;
}
const environmentPathRE = /^environments\.[^.]+$/;
function mergeWithDefaults(defaults, values) {
	const clonedDefaults = deepClone(defaults);
	return mergeWithDefaultsRecursively(clonedDefaults, values);
}
function mergeConfigRecursively(defaults, overrides, rootPath) {
	const merged = { ...defaults };
	for (const key in overrides) {
		const value$1 = overrides[key];
		if (value$1 == null) continue;
		const existing = merged[key];
		if (existing == null) {
			merged[key] = value$1;
			continue;
		}
		if (key === "alias" && (rootPath === "resolve" || rootPath === "")) {
			merged[key] = mergeAlias(existing, value$1);
			continue;
		} else if (key === "assetsInclude" && rootPath === "") {
			merged[key] = [].concat(existing, value$1);
			continue;
		} else if ((key === "noExternal" && (rootPath === "ssr" || rootPath === "resolve") || key === "allowedHosts" && rootPath === "server") && (existing === true || value$1 === true)) {
			merged[key] = true;
			continue;
		} else if (key === "plugins" && rootPath === "worker") {
			merged[key] = () => [...backwardCompatibleWorkerPlugins(existing), ...backwardCompatibleWorkerPlugins(value$1)];
			continue;
		} else if (key === "server" && rootPath === "server.hmr") {
			merged[key] = value$1;
			continue;
		}
		if (Array.isArray(existing) || Array.isArray(value$1)) {
			merged[key] = [...arraify(existing), ...arraify(value$1)];
			continue;
		}
		if (isObject(existing) && isObject(value$1)) {
			merged[key] = mergeConfigRecursively(existing, value$1, rootPath && !environmentPathRE.test(rootPath) ? `${rootPath}.${key}` : key);
			continue;
		}
		merged[key] = value$1;
	}
	return merged;
}
function mergeConfig(defaults, overrides, isRoot = true) {
	if (typeof defaults === "function" || typeof overrides === "function") throw new Error(`Cannot merge config in form of callback`);
	return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
}
function mergeAlias(a, b) {
	if (!a) return b;
	if (!b) return a;
	if (isObject(a) && isObject(b)) return {
		...a,
		...b
	};
	return [...normalizeAlias(b), ...normalizeAlias(a)];
}
function normalizeAlias(o$1 = []) {
	return Array.isArray(o$1) ? o$1.map(normalizeSingleAlias) : Object.keys(o$1).map((find$1) => normalizeSingleAlias({
		find: find$1,
		replacement: o$1[find$1]
	}));
}
function normalizeSingleAlias({ find: find$1, replacement, customResolver }) {
	if (typeof find$1 === "string" && find$1.endsWith("/") && replacement.endsWith("/")) {
		find$1 = find$1.slice(0, find$1.length - 1);
		replacement = replacement.slice(0, replacement.length - 1);
	}
	const alias$2 = {
		find: find$1,
		replacement
	};
	if (customResolver) alias$2.customResolver = customResolver;
	return alias$2;
}
/**
* Transforms transpiled code result where line numbers aren't altered,
* so we can skip sourcemap generation during dev
*/
function transformStableResult(s$2, id, config$2) {
	return {
		code: s$2.toString(),
		map: config$2.command === "build" && config$2.build.sourcemap ? s$2.generateMap({
			hires: "boundary",
			source: id
		}) : null
	};
}
async function asyncFlatten(arr) {
	do
		arr = (await Promise.all(arr)).flat(Infinity);
	while (arr.some((v) => v?.then));
	return arr;
}
function stripBomTag(content) {
	if (content.charCodeAt(0) === 65279) return content.slice(1);
	return content;
}
const windowsDrivePathPrefixRE = /^[A-Za-z]:[/\\]/;
/**
* path.isAbsolute also returns true for drive relative paths on windows (e.g. /something)
* this function returns false for them but true for absolute paths (e.g. C:/something)
*/
const isNonDriveRelativeAbsolutePath = (p) => {
	if (!isWindows) return p[0] === "/";
	return windowsDrivePathPrefixRE.test(p);
};
/**
* Determine if a file is being requested with the correct case, to ensure
* consistent behavior between dev and prod and across operating systems.
*/
function shouldServeFile(filePath, root) {
	if (!isCaseInsensitiveFS) return true;
	return hasCorrectCase(filePath, root);
}
/**
* Note that we can't use realpath here, because we don't want to follow
* symlinks.
*/
function hasCorrectCase(file, assets) {
	if (file === assets) return true;
	const parent = path.dirname(file);
	if (fs.readdirSync(parent).includes(path.basename(file))) return hasCorrectCase(parent, assets);
	return false;
}
function joinUrlSegments(a, b) {
	if (!a || !b) return a || b || "";
	if (a.endsWith("/")) a = a.substring(0, a.length - 1);
	if (b[0] !== "/") b = "/" + b;
	return a + b;
}
function removeLeadingSlash(str) {
	return str[0] === "/" ? str.slice(1) : str;
}
function stripBase(path$13, base) {
	if (path$13 === base) return "/";
	const devBase = withTrailingSlash(base);
	return path$13.startsWith(devBase) ? path$13.slice(devBase.length - 1) : path$13;
}
function arrayEqual(a, b) {
	if (a === b) return true;
	if (a.length !== b.length) return false;
	for (let i$1 = 0; i$1 < a.length; i$1++) if (a[i$1] !== b[i$1]) return false;
	return true;
}
function evalValue(rawValue) {
	const fn = new Function(`
    var console, exports, global, module, process, require
    return (\n${rawValue}\n)
  `);
	return fn();
}
function getNpmPackageName(importPath) {
	const parts = importPath.split("/");
	if (parts[0][0] === "@") {
		if (!parts[1]) return null;
		return `${parts[0]}/${parts[1]}`;
	} else return parts[0];
}
function getPkgName(name) {
	return name[0] === "@" ? name.split("/")[1] : name;
}
const escapeRegexRE$1 = /[-/\\^$*+?.()|[\]{}]/g;
function escapeRegex(str) {
	return str.replace(escapeRegexRE$1, "\\$&");
}
function getPackageManagerCommand(type = "install") {
	const packageManager = process.env.npm_config_user_agent?.split(" ")[0].split("/")[0] || "npm";
	switch (type) {
		case "install": return packageManager === "npm" ? "npm install" : `${packageManager} add`;
		case "uninstall": return packageManager === "npm" ? "npm uninstall" : `${packageManager} remove`;
		case "update": return packageManager === "yarn" ? "yarn upgrade" : `${packageManager} update`;
		default: throw new TypeError(`Unknown command type: ${type}`);
	}
}
function isDevServer(server) {
	return "pluginContainer" in server;
}
function createSerialPromiseQueue() {
	let previousTask;
	return { async run(f$1) {
		const thisTask = f$1();
		const depTasks = Promise.all([previousTask, thisTask]);
		previousTask = depTasks;
		const [, result] = await depTasks;
		if (previousTask === depTasks) previousTask = void 0;
		return result;
	} };
}
function sortObjectKeys(obj) {
	const sorted = {};
	for (const key of Object.keys(obj).sort()) sorted[key] = obj[key];
	return sorted;
}
function displayTime(time) {
	if (time < 1e3) return `${time}ms`;
	time = time / 1e3;
	if (time < 60) return `${time.toFixed(2)}s`;
	const mins = Math.floor(time / 60);
	const seconds = Math.round(time % 60);
	if (seconds === 60) return `${mins + 1}m`;
	return `${mins}m${seconds < 1 ? "" : ` ${seconds}s`}`;
}
/**
* Encodes the URI path portion (ignores part after ? or #)
*/
function encodeURIPath(uri) {
	if (uri.startsWith("data:")) return uri;
	const filePath = cleanUrl(uri);
	const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
	return encodeURI(filePath) + postfix;
}
/**
* Like `encodeURIPath`, but only replacing `%` as `%25`. This is useful for environments
* that can handle un-encoded URIs, where `%` is the only ambiguous character.
*/
function partialEncodeURIPath(uri) {
	if (uri.startsWith("data:")) return uri;
	const filePath = cleanUrl(uri);
	const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
	return filePath.replaceAll("%", "%25") + postfix;
}
const sigtermCallbacks = /* @__PURE__ */ new Set();
const parentSigtermCallback = async (signal, exitCode) => {
	await Promise.all([...sigtermCallbacks].map((cb) => cb(signal, exitCode)));
};
const setupSIGTERMListener = (callback) => {
	if (sigtermCallbacks.size === 0) {
		process.once("SIGTERM", parentSigtermCallback);
		if (process.env.CI !== "true") process.stdin.on("end", parentSigtermCallback);
	}
	sigtermCallbacks.add(callback);
};
const teardownSIGTERMListener = (callback) => {
	sigtermCallbacks.delete(callback);
	if (sigtermCallbacks.size === 0) {
		process.off("SIGTERM", parentSigtermCallback);
		if (process.env.CI !== "true") process.stdin.off("end", parentSigtermCallback);
	}
};
function getServerUrlByHost(resolvedUrls, host) {
	if (typeof host === "string") {
		const matchedUrl = [...resolvedUrls?.local ?? [], ...resolvedUrls?.network ?? []].find((url$3) => url$3.includes(host));
		if (matchedUrl) return matchedUrl;
	}
	return resolvedUrls?.local[0] ?? resolvedUrls?.network[0];
}
let lastDateNow = 0;
/**
* Similar to `Date.now()`, but strictly monotonically increasing.
*
* This function will never return the same value.
* Thus, the value may differ from the actual time.
*
* related: https://github.com/vitejs/vite/issues/19804
*/
function monotonicDateNow() {
	const now = Date.now();
	if (now > lastDateNow) {
		lastDateNow = now;
		return lastDateNow;
	}
	lastDateNow++;
	return lastDateNow;
}

//#endregion
//#region src/node/plugin.ts
async function resolveEnvironmentPlugins(environment) {
	const environmentPlugins = [];
	for (const plugin of environment.getTopLevelConfig().plugins) {
		if (plugin.applyToEnvironment) {
			const applied = await plugin.applyToEnvironment(environment);
			if (!applied) continue;
			if (applied !== true) {
				environmentPlugins.push(...(await asyncFlatten(arraify(applied))).filter(Boolean));
				continue;
			}
		}
		environmentPlugins.push(plugin);
	}
	return environmentPlugins;
}
/**
* @experimental
*/
function perEnvironmentPlugin(name, applyToEnvironment) {
	return {
		name,
		applyToEnvironment
	};
}

//#endregion
//#region ../../node_modules/.pnpm/commondir@1.0.1/node_modules/commondir/index.js
var require_commondir = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commondir@1.0.1/node_modules/commondir/index.js": ((exports, module) => {
	var path$12 = __require("path");
	module.exports = function(basedir, relfiles) {
		if (relfiles) var files = relfiles.map(function(r$2) {
			return path$12.resolve(basedir, r$2);
		});
		else var files = basedir;
		var res = files.slice(1).reduce(function(ps, file) {
			if (!file.match(/^([A-Za-z]:)?\/|\\/)) throw new Error("relative path without a basedir");
			var xs = file.split(/\/+|\\+/);
			for (var i$1 = 0; ps[i$1] === xs[i$1] && i$1 < Math.min(ps.length, xs.length); i$1++);
			return ps.slice(0, i$1);
		}, files[0].split(/\/+|\\+/));
		return res.length > 1 ? res.join("/") : "/";
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/magic-string@0.30.17/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}
	add(n$2) {
		this.bits[n$2 >> 5] |= 1 << (n$2 & 31);
	}
	has(n$2) {
		return !!(this.bits[n$2 >> 5] & 1 << (n$2 & 31));
	}
};
var Chunk = class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		this.previous = null;
		this.next = null;
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", void 0, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", void 0, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
	else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa$1 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode$1(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min$1 = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min$1 + 1).join(" ");
}
function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i$1 = fromParts.length;
		while (i$1--) fromParts[i$1] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString$1 = Object.prototype.toString;
function isObject$2(thing) {
	return toString$1.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i$1 = 0, pos = 0; i$1 < originalLines.length; i$1++) {
		lineOffsets.push(pos);
		pos += originalLines[i$1].length + 1;
	}
	return function locate(index) {
		let i$1 = 0;
		let j = lineOffsets.length;
		while (i$1 < j) {
			const m$2 = i$1 + j >> 1;
			if (index < lineOffsets[m$2]) j = m$2;
			else i$1 = m$2 + 1;
		}
		const line = i$1 - 1;
		const column = index - lineOffsets[line];
		return {
			line,
			column
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first$2 = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first$2 = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first$2 || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
					else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first$2 = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i$1 = 0; i$1 < lines.length - 1; i$1++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n$1 = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString {
	constructor(string, options$1 = {}) {
		const chunk = new Chunk(0, string.length, string);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options$1.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options$1.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: void 0
			},
			ignoreList: {
				writable: true,
				value: options$1.ignoreList
			},
			offset: {
				writable: true,
				value: options$1.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
		else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
		else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options$1) {
		options$1 = options$1 || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options$1.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
			else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		return {
			file: options$1.file ? options$1.file.split(/[/\\]/).pop() : void 0,
			sources: [options$1.source ? getRelativePath(options$1.file || "", options$1.source) : options$1.file || ""],
			sourcesContent: options$1.includeContent ? [this.original] : void 0,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
		};
	}
	generateMap(options$1) {
		return new SourceMap(this.generateDecodedMap(options$1));
	}
	_ensureindentStr() {
		if (this.indentStr === void 0) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options$1) {
		const pattern = /^[^\r\n]/gm;
		if (isObject$2(indentStr)) {
			options$1 = indentStr;
			indentStr = void 0;
		}
		if (indentStr === void 0) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options$1 = options$1 || {};
		const isExcluded = {};
		if (options$1.exclude) {
			const exclusions = typeof options$1.exclude[0] === "number" ? [options$1.exclude] : options$1.exclude;
			exclusions.forEach((exclusion) => {
				for (let i$1 = exclusion[0]; i$1 < exclusion[1]; i$1 += 1) isExcluded[i$1] = true;
			});
		}
		let shouldIndentNextCharacter = options$1.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
						else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
							else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first$2 = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first$2.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first$2;
		if (newRight) newRight.previous = last;
		if (!first$2.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first$2.previous;
			this.lastChunk.next = null;
		}
		first$2.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first$2;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options$1) {
		options$1 = options$1 || {};
		return this.update(start, end, content, {
			...options$1,
			overwrite: !options$1.contentOnly
		});
	}
	update(start, end, content, options$1) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options$1 === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options$1 = { storeName: true };
		}
		const storeName = options$1 !== void 0 ? options$1.storeName : false;
		const overwrite = options$1 !== void 0 ? options$1.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first$2 = this.byStart[start];
		const last = this.byEnd[end];
		if (first$2) {
			let chunk = first$2;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first$2.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
		else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
		else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone$1 = this.clone();
		clone$1.remove(0, start);
		clone$1.remove(end, clone$1.original.length);
		return clone$1;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i$1) => {
				if (i$1 === "$") return "$";
				if (i$1 === "&") return match[0];
				const num = +i$1;
				if (num < match.length) return match[+i$1];
				return `$${i$1}`;
			});
			else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll$1(re, str) {
			let match;
			const matches$2 = [];
			while (match = re.exec(str)) matches$2.push(match);
			return matches$2;
		}
		if (searchValue.global) {
			const matches$2 = matchAll$1(searchValue, this.original);
			matches$2.forEach((match) => {
				if (match.index != null) {
					const replacement$1 = getReplacement(match, this.original);
					if (replacement$1 !== match[0]) this.overwrite(match.index, match.index